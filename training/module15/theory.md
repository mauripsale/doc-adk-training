# Module 15: Handling Files with Artifacts

## Theory

### Agents That Do More Than Talk

So far, our agents have worked exclusively with text. But in many real-world scenarios, agents need to handle files: reading documents, analyzing images, or generating reports.

The ADK provides a robust system for managing files and binary data through a concept called **Artifacts**. An artifact is any piece of data that isn't part of the regular text-based conversation, such as:

*   A PDF document a user uploads for summarization.
*   A CSV file an agent needs to analyze.
*   An image generated by the agent.
*   A PDF invoice created by a tool.

### The Artifact Service

At the core of this system is the **Artifact Service**. This is a component responsible for storing and retrieving artifacts. The ADK provides a simple `InMemoryArtifactService` for local development, but in a production environment, this could be a more robust service that stores files in a cloud storage bucket (like Google Cloud Storage).

This service-based approach means that the agent's logic doesn't need to worry about *where* the files are stored. It simply interacts with the service to save and load data.

### How Agents and Tools Interact with Artifacts

The primary way to work with artifacts is from within a **custom tool** using the `ToolContext`. The `ToolContext` provides a set of convenient methods for artifact management.

#### 1. **Uploading Artifacts**
In the ADK Developer UI, there is a paperclip icon that allows you, the user, to upload a file. When you do this, the file is sent to the Artifact Service, which stores it and makes it available to the agent for the current session.

#### 2. **Listing Artifacts (`tool_context.list_artifacts`)**
A tool can ask for a list of all files that have been uploaded in the current session. This is useful if the agent needs to know what files are available to be processed.

```python
def list_uploaded_files(tool_context: ToolContext) -> dict:
    """Lists all files the user has uploaded in this session."""
    # This returns a list of filenames.
    artifact_names = tool_context.list_artifacts()
    return {"status": "success", "files": artifact_names}
```

#### 3. **Loading Artifacts (`tool_context.load_artifact`)**
This is the most common operation. A tool can request the content of a specific artifact by its filename.

```python
def read_document(filename: str, tool_context: ToolContext) -> dict:
    """Reads the text content of an uploaded document."""
    try:
        # load_artifact returns a special 'Part' object.
        artifact_part = tool_context.load_artifact(filename)
        if artifact_part:
            # We can get the text content from the Part object.
            text_content = artifact_part.text
            return {"status": "success", "content": text_content}
        else:
            return {"status": "error", "message": f"File '{filename}' not found."}
    except Exception as e:
        return {"status": "error", "message": str(e)}
```

#### 4. **Saving Artifacts (`tool_context.save_artifact`)**
Tools can also *create* new artifacts. This is useful for agents that generate files, such as reports, images, or data exports.

```python
from google.genai.types import Part

def create_report(content: str, tool_context: ToolContext) -> dict:
    """Creates a text file report and saves it as an artifact."""
    # We create a 'Part' object from our text content.
    report_part = Part.from_text(content)
    
    # We save the Part as a new artifact.
    tool_context.save_artifact(filename="summary_report.txt", artifact=report_part)
    
    return {"status": "success", "message": "Report 'summary_report.txt' has been created."}
```

By using these methods within your custom tools, you can build agents that go beyond simple text-based interactions and perform complex tasks involving file I/O, making them significantly more powerful and useful.

In the lab for this module, you will build an agent that can read and summarize the content of a user-uploaded text file.
